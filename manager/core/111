Я выяснил что для создания выдачи СИЗ в моем проекте, нужно предварительно создать объект Item.
После того, как я создал перчатки через shell их стало можно выбрать в форме выдачи СИЗ. Но я то думал что форма выдачи СИЗ это и есть создание предмета в БД. По крайней мере так должно быть. Ты можешь это сделать?
Вот мои текущие models.py:
```
from django.db import models
from django.core.exceptions import ValidationError
from dateutil.relativedelta import relativedelta

class Position(models.Model):
    position_name = models.CharField(
        "Название должности",
        max_length=100,
        unique=True
    )
    
    class Meta:
        verbose_name = "Должность"
        verbose_name_plural = "Должности"
    
    def __str__(self):
        return self.position_name

class Employee(models.Model):
    # Существующие поля
    first_name = models.CharField("Имя", max_length=50)
    last_name = models.CharField("Фамилия", max_length=50)
    patronymic = models.CharField("Отчество", max_length=50)
    position = models.ForeignKey(
        Position,
        on_delete=models.SET_NULL,
        verbose_name="Должность",
        null=True,
        related_name="employees"
    )
    department = models.CharField("Подразделение", max_length=50)
    
    BODY_SIZE_CHOICES = [
        ("40-42/158-164", "40-42/158-164"),
        ("44-46/158-164", "44-46/158-164"),
        ("44-46/170-176", "44-46/170-176"),
        ("44-46/182-188", "44-46/182-188"),
        ("44-46/194-200", "44-46/194-200"),
        ("48-50/158-164", "48-50/158-164"),
        ("48-50/170-176", "48-50/170-176"),
        ("48-50/182-188", "48-50/182-188"),
        ("48-50/194-200", "48-50/194-200"),
        ("52-54/158-164", "52-54/158-164"),
        ("52-54/170-176", "52-54/170-176"),
        ("52-54/182-188", "52-54/182-188"),
        ("52-54/194-200", "52-54/194-200"),
        ("56-58/158-164", "56-58/158-164"),
        ("56-58/170-176", "56-58/170-176"),
        ("56-58/182-188", "56-58/182-188"),
        ("56-58/194-200", "56-58/194-200"),
        ("60-62/158-164", "60-62/158-164"),
        ("60-62/170-176", "60-62/170-176"),
        ("60-62/182-188", "60-62/182-188"),
        ("60-62/194-200", "60-62/194-200"),
        ("64-66/158-164", "64-66/158-164"),
        ("64-66/170-176", "64-66/170-176"),
        ("64-66/182-188", "64-66/182-188"),
        ("64-66/194-200", "64-66/194-200"),
        ("68-70/158-164", "68-70/158-164"),
        ("68-70/170-176", "68-70/170-176"),
        ("68-70/182-188", "68-70/182-188"),
        ("68-70/194-200", "68-70/194-200"),
        ("72-74/194-200", "72-74/194-200"),
    ]
    
    HEAD_SIZE_CHOICES = [
        ("51", "51"),
        ("52", "52"),
        ("53", "53"),
        ("54", "54"),
        ("55", "55"),
        ("56", "56"),
        ("57", "57"),
        ("58", "58"),
        ("59", "59"),
        ("60", "60"),
        ("61", "61"),
        ("62", "62"),
        ("63", "63"),
    ]
    
    GLOVE_SIZE_CHOICES = [
        (6.0, 6.0),
        (6.5, 6.5),
        (7.0, 7.0),
        (7.5, 7.5),
        (8.0, 8.0),
        (8.5, 8.5),
        (9.0, 9.0),
        (9.5, 9.5),
        (10.0, 10.0),
        (10.5, 10.5),
        (11.0, 11.0),
        (11.5, 11.5),
        (12.0, 12.0),
    ]
    
    SHOE_SIZE_CHOICES = [(i, str(i)) for i in range(35, 53)]  # 35-52
    
    body_size = models.CharField(
        "Размер спецодежды (тело)",
        max_length=40,
        choices=BODY_SIZE_CHOICES,
        blank=True,
        null=True,
        help_text="Пример: 44-46/158-164"
    )
    
    head_size = models.CharField(
        "Размер головного убора",
        max_length=3,
        choices=HEAD_SIZE_CHOICES,
        blank=True,
        null=True,
        help_text="Пример: 56, 57, 58"
    )
    
    glove_size = models.FloatField(
        "Размер перчаток",
        choices=GLOVE_SIZE_CHOICES,
        blank=True,
        null=True,
        help_text="Пример: 8.0, 8.5 ... 11.0"
    )
    
    shoe_size = models.IntegerField(
        "Размер обуви",
        choices=SHOE_SIZE_CHOICES,
        blank=True,
        null=True,
        help_text="Пример: 35, 36 ... 52"
    )
    
    class Meta:
        verbose_name = "Сотрудник"
        verbose_name_plural = "Сотрудники"
        ordering = ["last_name", "first_name", "patronymic"]
    
    def issue_item(self, item_type, quantity=1, issue_date=None, expiration_date=None):
        """
        Выдает указанное количество СИЗ сотруднику.
        """
        if not issue_date:
            raise ValueError("Поле 'Дата выдачи' обязательно для заполнения.")
        
        for _ in range(quantity):
            Issue.objects.create(
                employee=self,
                item_type=item_type,
                issue_date=issue_date,
                expiration_date=expiration_date
            )
    
    def __str__(self):
        return f"{self.last_name} {self.first_name} {self.patronymic}".strip()

    # Логика не финальная
    def get_position_change_report(self, new_position):
        """
        Возвращает отчет о необходимых изменениях при переводе на новую должность.
        Формат:
        {
            "to_remove": {item: количество_к_списанию},
            "to_issue": {item: количество_к_выдаче}
        }
        """
        # Текущие активные выдачи сотрудника
        current_issues = self.issues.filter(is_active=True)
        
        # Нормы для новой должности
        new_norms = Norm.objects.filter(position=new_position)
        
        # СИЗ, которые должны быть у сотрудника по новой должности
        required_items = {norm.item: norm.quantity for norm in new_norms}
        
        # СИЗ, которые есть у сотрудника сейчас
        current_items = {}
        for issue in current_issues:
            current_items[issue.item] = current_items.get(issue.item, 0) + 1
        
        # Определяем избыточные СИЗ
        items_to_remove = {}
        for item, count in current_items.items():
            required_count = required_items.get(item, 0)
            if count > required_count:
                items_to_remove[item] = count - required_count
        
        # Определяем недостающие СИЗ
        items_to_add = {}
        for item, required_count in required_items.items():
            current_count = current_items.get(item, 0)
            if required_count > current_count:
                items_to_add[item] = required_count - current_count
        
        return {
            "to_remove": items_to_remove,
            "to_issue": items_to_add
        }

class PPEType(models.Model):
    name = models.CharField(
        "Тип СИЗ",
        max_length=255,
        unique=True,
        help_text="Укажите тип средства индивидуальной защиты"
    )
    
    class Meta:
        verbose_name = "Тип СИЗ"
        verbose_name_plural = "Типы СИЗ"
        ordering = ['name']

    def __str__(self):
        return self.name

class Item(models.Model):
    MEASUREMENT_UNITS = (
        ("шт.", "штук"),
        ("пар.", "пар"),
        ("компл.", "комплектов"),
        ("г.", "грамм"),
        ("мл.", "миллилитров"),
    )
    ppe_type = models.ForeignKey(
        PPEType,
        on_delete=models.CASCADE,
        related_name='items',
        verbose_name="Тип СИЗ"
    )
    item_name = models.CharField(
        "Наименование",
        max_length=250,
        help_text="Наименование СИЗ, предмета"
    )
    item_lifespan = models.PositiveIntegerField(
        "Срок годности (в месяцах)",
        help_text="Срок годности (в месяцах)"
    )
    item_size = models.CharField(
        "Размер",
        max_length=100,
    )
    item_mu = models.CharField(
        "Единица измерения",
        max_length=10,
        choices=MEASUREMENT_UNITS,
        default="шт."
    )
    
    class Meta:
        verbose_name = "СИЗ"
        verbose_name_plural = "СИЗ"
    
    def __str__(self):
        return f"{self.item_name}, ({self.get_item_mu_display()})"

class Norm(models.Model):
    position = models.ForeignKey(
        Position,
        on_delete=models.CASCADE,
        related_name='norms'
    )
    ppe_type = models.ForeignKey(
        PPEType,
        on_delete=models.CASCADE,
        related_name='norms'
    )
    quantity = models.PositiveIntegerField(
        "Количество",
        help_text="Сколько единиц СИЗ положено для этой должности"
    )

    class Meta:
        unique_together = ['position', 'ppe_type']
        verbose_name = "Норма выдачи"
        verbose_name_plural = "Нормы выдачи"
    
    def __str__(self):
        return f"{self.position}: {self.item_type} x{self.quantity}"


class Issue(models.Model):
    employee = models.ForeignKey(
        Employee, 
        on_delete=models.CASCADE,
        verbose_name="Сотрудник",
        related_name='issues'
    )
    item = models.ForeignKey(
        Item,
        on_delete=models.CASCADE,
        related_name='issues',
        verbose_name="СИЗ"
    )
    issue_date = models.DateField(
        "Дата выдачи",
    )
    expiration_date = models.DateField(
        "Срок годности",
        blank=True,
        null=True
    )
    is_active = models.BooleanField(
        "Активно",
        default=True
    )

    def save(self, *args, **kwargs):
        if not self.expiration_date and self.item.item_lifespan:
            self.expiration_date = self.issue_date + relativedelta(months=self.item.item_lifespan)
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.employee} - {self.item} ({self.issue_date})"
```
views.py:
```
import json
from xmlrpc.client import Boolean
from django.shortcuts import render, get_object_or_404, redirect
from django.http import HttpResponseRedirect
from .models import Employee, Position, Norm, Item, Issue, PPEType
from users.models import CustomUser
from django.core.paginator import Paginator
from django.utils import timezone
# from .forms import ItemForm
from django.contrib.auth.decorators import login_required
from dateutil.relativedelta import relativedelta
from collections import defaultdict
from datetime import datetime, date, timedelta
import openpyxl
import logging
from .forms import EmployeeForm, PositionForm, NormCreateForm, IssueCreateForm
from django.urls import reverse
from django.http import JsonResponse


logger = logging.getLogger(__name__)


def index(request):
    title = "Главная страница"
    
    # Получаем все активные выдачи СИЗ с предзагрузкой связанных объектов
    issue_list = Issue.objects.select_related('employee', 'item').filter(is_active=True).order_by('employee', '-issue_date')
    
    # Группируем выдачи по сотрудникам
    grouped_issues = defaultdict(list)
    for issue in issue_list:
        grouped_issues[issue.employee].append(issue)
    
    context = {
        'title': title,
        'grouped_issues': dict(grouped_issues),
        'user': request.user,
        'current_date': timezone.now().date()
    }
    return render(request, 'core/index.html', context)


@login_required
def position_list(request):
    positions = Position.objects.all()
    return render(request, 'core/position_list.html', {'positions': positions})


@login_required
def list_items(request, employee_id):
    employee = get_object_or_404(Employee, pk=employee_id)
    # Get all issues for the employee
    issues = Issue.objects.filter(employee=employee)
    # Extract the items from the issues
    items = [issue.item for issue in issues]
    return render(request, 'core/list_items.html', {'items': items, 'employee': employee})


@login_required
def profile(request, username):
    author_obj = get_object_or_404(CustomUser, username=username)
    # items = author_obj.items.all()
    # paginator = Paginator(items, 30)
    # page_number = request.GET.get('page')
    # page_obj = paginator.get_page(page_number)
    context = {
        'author_obj': author_obj,
        # 'items': items,
        # 'page_obj': page_obj,
    }
    return render(request, 'core/profile.html', context)


@login_required
def employee_create(request):
    if request.method == 'POST':
        form = EmployeeForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('core:index')  # Redirect to the index page after successful creation
    else:
        form = EmployeeForm()
    return render(request, 'core/create_employee.html', {'form': form})


@login_required
def position_create(request):
    if request.method == 'POST':
        form = PositionForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('core:index')  # Redirect to the index page after successful creation
    else:
        form = PositionForm()
    return render(request, 'core/create_position.html', {'form': form})


@login_required
def create_norm(request, position_id):
    position = get_object_or_404(Position, pk=position_id)
    
    if request.method == 'POST':
        form = NormCreateForm(request.POST, position=position)
        if form.is_valid():
            form.save()
            return redirect('core:position_detail', position_id=position.id)
    else:
        form = NormCreateForm(position=position)
    
    return render(request, 'core/create_norm.html', {
        'form': form,
        'position': position
    })


@login_required
def position_detail(request, position_id):
    position = get_object_or_404(Position, pk=position_id)
    norms = Norm.objects.filter(position=position)
    return render(request, 'core/position_detail.html', {'position': position, 'norms': norms})


@login_required
def employee_list(request):
    employees = Employee.objects.all()
    return render(request, 'core/employee_list.html', {'employees': employees})

from django.shortcuts import get_object_or_404, render

@login_required
def employee_detail(request, employee_id):
    employee = get_object_or_404(Employee, pk=employee_id)
    issues = Issue.objects.filter(employee=employee)
    return render(request, 'core/employee_detail.html', {'employee': employee, 'issues': issues})

from django.shortcuts import get_object_or_404, redirect, render
from django.contrib import messages
from django.views.decorators.http import require_http_methods
from django.contrib.auth.decorators import login_required
from .models import Norm, Position

@login_required
def norm_edit(request, position_id):
    position = get_object_or_404(
        Position.objects.prefetch_related('norms__ppe_type'), 
        pk=position_id
    )
    return render(request, 'core/norm_edit.html', {
        'position': position,
        'norms': position.norms.all()
    })

@login_required
@require_http_methods(["POST"])
def norm_update(request, norm_id):
    try:
        norm = Norm.objects.select_related('position').get(pk=norm_id)
        quantity = int(request.POST.get('quantity', 0))
        
        if quantity < 1:
            raise ValueError("Количество должно быть положительным числом")
            
        norm.quantity = quantity
        norm.save()
        messages.success(request, f"Норма для {norm.ppe_type.name} обновлена")
        
    except Norm.DoesNotExist:
        messages.error(request, "Норма не найдена")
    except ValueError as e:
        messages.error(request, str(e))
    except Exception as e:
        messages.error(request, f"Ошибка при обновлении: {str(e)}")
    
    return redirect('core:norm_edit', position_id=norm.position.id)

@login_required
@require_http_methods(["POST"])
def norm_delete(request, norm_id):
    try:
        norm = Norm.objects.select_related('position').get(pk=norm_id)
        position_id = norm.position.id
        ppe_type_name = norm.ppe_type.name
        norm.delete()
        messages.success(request, f"Норма для {ppe_type_name} удалена")
    except Norm.DoesNotExist:
        messages.error(request, "Норма не найдена")
    except Exception as e:
        messages.error(request, f"Ошибка при удалении: {str(e)}")
    
    return redirect('core:norm_edit', position_id=position_id)


@login_required
def create_issue(request, employee_id):
    employee = get_object_or_404(Employee.objects.select_related('position'), pk=employee_id)
    
    if not employee.position:
        messages.error(request, "Сотрудник не имеет назначенной должности")
        return redirect('employee_list')
    
    if request.method == 'POST':
        form = IssueCreateForm(request.POST, employee=employee)
        if form.is_valid():
            # Сохранение с обработкой количества
            return redirect('core:employee_detail', employee_id=employee.id)
    else:
        form = IssueCreateForm(employee=employee)
    
    # Добавляем проверку пустого списка
    if not form.fields['item'].queryset.exists():
        messages.warning(request, "Нет доступных СИЗ по нормам текущей должности")
    
    return render(request, 'core/create_issue.html', {
        'form': form,
        'employee': employee
    })
    

def deactivate_issue(request, issue_id):
    issue = get_object_or_404(Issue, pk=issue_id)
    issue.is_active = False
    issue.save()
    return redirect('core:employee_detail', employee_id=issue.employee.id)
```
forms.py:
```
from django import forms
from django.core.exceptions import ValidationError
from .models import Employee

from django import forms
from .models import Employee, Position, Norm, Item, Issue, PPEType

class EmployeeForm(forms.ModelForm):
    class Meta:
        model = Employee
        fields = ['last_name', 'first_name', 'patronymic', 'position', 'department', 'body_size', 'head_size', 'glove_size', 'shoe_size']
        widgets = {
            'position': forms.Select(attrs={'class': 'form-control'})
        }

class PositionForm(forms.ModelForm):
    class Meta:
        model = Position
        fields = ['position_name']

class NormCreateForm(forms.ModelForm):
    new_ppe_type = forms.CharField(
        label="Новый тип СИЗ",
        required=False,
        help_text="Введите название нового типа",
        max_length=255
    )

    class Meta:
        model = Norm
        fields = ['ppe_type', 'quantity']
        labels = {
            'ppe_type': 'Существующий тип СИЗ',
            'quantity': 'Количество'
        }

    def __init__(self, *args, **kwargs):
        self.position = kwargs.pop('position', None)
        super().__init__(*args, **kwargs)
        self.fields['ppe_type'].queryset = PPEType.objects.exclude(
            norms__position=self.position
        )
        self.fields['ppe_type'].required = False

    def clean(self):
        cleaned_data = super().clean()
        ppe_type = cleaned_data.get('ppe_type')
        new_ppe_type = cleaned_data.get('new_ppe_type')

        if not ppe_type and not new_ppe_type:
            raise ValidationError("Необходимо выбрать тип СИЗ или ввести новый")

        if ppe_type and new_ppe_type:
            raise ValidationError("Выберите только один вариант: существующий тип или новый")

        if new_ppe_type:
            # Проверяем не существует ли уже такого типа
            if PPEType.objects.filter(name__iexact=new_ppe_type.strip()).exists():
                raise ValidationError("Такой тип СИЗ уже существует")
            
            # Проверяем не добавлен ли уже такой тип для этой должности
            if Norm.objects.filter(
                position=self.position,
                ppe_type__name__iexact=new_ppe_type.strip()
            ).exists():
                raise ValidationError("Этот тип СИЗ уже добавлен для данной должности")

        return cleaned_data

    def save(self, commit=True):
        instance = super().save(commit=False)
        instance.position = self.position
        
        new_type = self.cleaned_data.get('new_ppe_type')
        if new_type:
            ppe_type, created = PPEType.objects.get_or_create(
                name=new_type.strip()
            )
            instance.ppe_type = ppe_type

        if commit:
            instance.save()
        return instance


class IssueCreateForm(forms.ModelForm):
    quantity = forms.IntegerField(
        min_value=1,
        initial=1,
        label="Количество для выдачи"
    )

    class Meta:
        model = Issue
        fields = ['item', 'issue_date', 'expiration_date']
        widgets = {
            'issue_date': forms.DateInput(attrs={'type': 'date'}),
            'expiration_date': forms.DateInput(attrs={'type': 'date'}),
        }

    def __init__(self, *args, **kwargs):
        self.employee = kwargs.pop('employee')
        super().__init__(*args, **kwargs)
        
        # Получаем типы СИЗ из норм должности сотрудника
        ppe_types = PPEType.objects.filter(
            norms__position=self.employee.position
        ).distinct()
        
        # Фильтруем предметы по разрешенным типам
        self.fields['item'].queryset = Item.objects.filter(
            ppe_type__in=ppe_types
        ).select_related('ppe_type')
        
        # Добавляем стили и подсказки
        self.fields['item'].widget.attrs.update({'class': 'form-select'})
        self.fields['item'].empty_label = "Выберите СИЗ из списка"
        self.fields['item'].help_text = "Доступные СИЗ по нормам должности"
```
Вообще вот весь мой актуальный проект, если тебе нужны еще какие-то файлы: https://github.com/bearvar/siz_manager/tree/issue_func/manager